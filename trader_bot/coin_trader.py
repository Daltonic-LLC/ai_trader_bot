from .llm_handler import LLMHandler
from .data_handler import DataHandler
from .model_handler import ModelHandler
from .news_handler import NewsHandler
from services.coin_stats import CoinStatsService
from services.coin_news import NewsSentimentService
from services.coin_history import CoinHistory
from config import config
from services.coin_extractor import TopCoinsExtractor  # For extracting top coins
from .binance_client import BinanceClient  # For arbitrage trading
import json

class CoinTrader:
    def __init__(self, coin, override):
        self.coin = coin
        self.override = override
        self.history_service = CoinHistory()
        self.stats_service = CoinStatsService()
        self.news_service = NewsSentimentService()
        self.llm_handler = LLMHandler(
            base_url=config.chat_endpoint,
            model=config.chat_model,
            temperature=0.1,
            timeout=60,
            binance_api_key=config.binance_api_key,
            binance_api_secret=config.binance_api_secret
        )
        self.data_handler = DataHandler(self.history_service, self.coin, self.override)
        self.model_handler = ModelHandler()
        self.news_handler = NewsHandler(self.news_service, self.coin, self.override, self.llm_handler)

    def load_top_coins(self):
        """Loads the top coins from the most recent JSON file generated by TopCoinsExtractor."""
        extractor = TopCoinsExtractor()
        top_coins_data = extractor.load_most_recent_data()
        return [coin['symbol'] for coin in top_coins_data if coin['symbol'] != 'USDT']

    def get_current_price(self):
        """Fetches the current price of the coin."""
        stats_file = (self.stats_service.fetch_and_save_coin_stats(self.coin) if self.override 
                      else self.stats_service.get_latest_stats(self.coin))
        return stats_file.get("price", 0)

    def generate_report(self, current_price, predicted_close, news_sentiment, news_text, recommendation, arbitrage_details):
        """Generates a trading report with arbitrage details."""
        news_text_truncated = " ".join(news_text.split()[:50]) + ("..." if len(news_text.split()) > 50 else "")
        report = f"""
        Daily Report for {self.coin.upper()}:
        - Current Price: ${current_price}
        - Predicted Close: ${predicted_close:.2f}
        - News Sentiment: {news_sentiment:.2f}
        - News Text: {news_text_truncated}
        - Recommendation: {recommendation}
        Arbitrage Details:
        {arbitrage_details}
        """
        return report

    def run(self):
        """Executes the trading process with triangular arbitrage and returns the report."""
        # Fetch data for the specified coin
        df = self.data_handler.load_historical_data()
        df_features = self.data_handler.prepare_features(df)
        model, feature_cols = self.model_handler.train_model(df_features)
        predicted_close = self.model_handler.predict_close(model, df_features, feature_cols)
        current_price = self.get_current_price()
        news_sentiment, news_text = self.news_handler.process_news()  # Changed from news_summary to news_text

        # Check for triangular arbitrage opportunities
        top_coins = self.load_top_coins()
        binance_client = BinanceClient(config.binance_api_key, config.binance_api_secret, top_coins)
        triangle, direction, profit, opportunities = binance_client.find_best_arbitrage_opportunity()

        # Analyze arbitrage opportunities
        total_checked = len(opportunities)
        profitable_count = sum(1 for opp in opportunities if opp['is_profitable'])
        print(f"Checked {total_checked} currency pairs for arbitrage.")
        print(f"Found {profitable_count} profitable opportunities.")

        if triangle and profit > 0:
            # Execute arbitrage if profitable
            starting_amount = 100.0  # Example starting amount in USDT
            final_amount = binance_client.execute_arbitrage(triangle, direction, starting_amount)
            recommendation = "ARBITRAGE"
            arbitrage_details = f"Executed arbitrage: {triangle} ({direction}), Profit: {profit:.2%}\nChecked {total_checked} pairs, {profitable_count} were profitable."
            print(f"Executed arbitrage: {triangle} ({direction}), Profit: {profit:.2%}")
        else:
            # Fallback to LLM-based decision if no profitable arbitrage is found
            recommendation = self.llm_handler.decide(self.coin, current_price, predicted_close, news_sentiment, news_text)
            arbitrage_details = f"No profitable arbitrage opportunity executed.\nChecked {total_checked} pairs, {profitable_count} were profitable."

        # Generate and return the report
        return self.generate_report(current_price, predicted_close, news_sentiment, news_text, recommendation, arbitrage_details)